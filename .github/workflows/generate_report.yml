name: Generate Reports
on:
  push:
    paths: ["raw/*.csv"]
  workflow_dispatch: # 수동 실행 가능
    
permissions:
  contents: write
  actions: read
    
jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Generate Reports
        run: |
          echo "📊 Generating reports from raw data..."
          
          # Create Node.js script to process data
          cat > process_data.js << 'EOF'
          const fs = require('fs');
          
          function parseCSV(content) {
            const lines = content.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            return lines.slice(1).filter(line => line.trim()).map(line => {
              const values = line.split(',');
              const obj = {};
              headers.forEach((header, i) => {
                obj[header] = values[i] ? values[i].trim() : '';
              });
              return obj;
            });
          }
          
          function generatePivots() {
            const population = parseCSV(fs.readFileSync('raw/population.csv', 'utf8'));
            const quota = parseCSV(fs.readFileSync('raw/quota.csv', 'utf8'));
            const cutline = parseCSV(fs.readFileSync('raw/cutline.csv', 'utf8'));
            
            // Generate trends summary
            const pivots = [];
            pivots.push('year,metric,value');
            
            population.forEach(p => {
              pivots.push(`${p.year},population,${p.cohort18}`);
            });
            
            // Aggregate quota by year
            const quotaByYear = {};
            quota.forEach(q => {
              const year = q.year;
              quotaByYear[year] = (quotaByYear[year] || 0) + parseInt(q.quota || 0);
            });
            
            Object.entries(quotaByYear).forEach(([year, total]) => {
              pivots.push(`${year},quota_total,${total}`);
            });
            
            // Calculate median cutline by year
            const cutlineByYear = {};
            cutline.forEach(c => {
              const year = c.year;
              if (!cutlineByYear[year]) cutlineByYear[year] = [];
              cutlineByYear[year].push(parseFloat(c.cut_pct || 0));
            });
            
            Object.entries(cutlineByYear).forEach(([year, cuts]) => {
              cuts.sort((a, b) => a - b);
              const median = cuts[Math.floor(cuts.length / 2)] || 0;
              pivots.push(`${year},cut_pct_median,${median.toFixed(2)}`);
            });
            
            return pivots.join('\n');
          }
          
          function generateSummary() {
            const now = new Date().toISOString();
            const population = parseCSV(fs.readFileSync('raw/population.csv', 'utf8'));
            const quota = parseCSV(fs.readFileSync('raw/quota.csv', 'utf8'));
            
            const totalQuota = quota.reduce((sum, q) => sum + parseInt(q.quota || 0), 0);
            const latestYear = Math.max(...population.map(p => parseInt(p.year)));
            const latestPopulation = population.find(p => parseInt(p.year) === latestYear)?.cohort18 || 0;
            
            return JSON.stringify({
              generated_at: now,
              latest_year: latestYear,
              latest_population: parseInt(latestPopulation),
              total_quota: totalQuota,
              data_files: ['population.csv', 'quota.csv', 'cutline.csv', 'cost.csv'],
              notes: '엔진 실행 시 최신 값으로 저장',
              trigger: 'GitHub Actions automation'
            }, null, 2);
          }
          
          function generateReport() {
            const now = new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
            const population = parseCSV(fs.readFileSync('raw/population.csv', 'utf8'));
            const quota = parseCSV(fs.readFileSync('raw/quota.csv', 'utf8'));
            const cutline = parseCSV(fs.readFileSync('raw/cutline.csv', 'utf8'));
            
            const years = [...new Set(population.map(p => parseInt(p.year)))].sort();
            const latestYear = Math.max(...years);
            const prevYear = latestYear - 1;
            
            const currentPop = population.find(p => parseInt(p.year) === latestYear)?.cohort18 || 0;
            const prevPop = population.find(p => parseInt(p.year) === prevYear)?.cohort18 || 0;
            const popChange = prevPop ? ((currentPop - prevPop) / prevPop * 100).toFixed(2) : 'N/A';
            
            const totalQuota = quota.reduce((sum, q) => sum + parseInt(q.quota || 0), 0);
            const avgCutline = cutline.length ? 
              (cutline.reduce((sum, c) => sum + parseFloat(c.cut_pct || 0), 0) / cutline.length).toFixed(2) : 'N/A';
            
            return `# EduMission 자동 생성 리포트

**생성 일시:** ${now}

## 📊 데이터 요약

### 인구 동향
- 최신 연도: ${latestYear}년
- 현재 18세 인구: ${parseInt(currentPop).toLocaleString()}명
- 전년 대비 증감률: ${popChange}%

### 대학 입시 현황
- 총 모집정원: ${totalQuota.toLocaleString()}명
- 평균 커트라인: ${avgCutline} 백분위
- 데이터 기준 연도: ${Math.min(...years)}~${Math.max(...years)}

### 분석 대상
- 대학 수: ${new Set(quota.map(q => q.univ)).size}개
- 학과 수: ${new Set(quota.map(q => q.dept)).size}개
- 전형 유형: ${new Set(quota.map(q => q.scheme)).size}개

## 🔄 자동화 상태

✅ **데이터 파이프라인 정상 작동**
- 트리거: raw/*.csv 파일 변경 감지
- 실행 시각: ${now}
- 처리된 데이터: 2024-2026 인구 동향

---

*이 리포트는 raw/*.csv 파일 변경 시 자동으로 생성됩니다.*`;
          }
          
          // Generate all outputs
          try {
            console.log('📁 Reading input files...');
            console.log('  - raw/population.csv');
            console.log('  - raw/quota.csv');  
            console.log('  - raw/cutline.csv');
            
            fs.writeFileSync('outputs/pivots.csv', generatePivots());
            fs.writeFileSync('outputs/summary.json', generateSummary());
            fs.writeFileSync('outputs/report.md', generateReport());
            
            console.log('✅ Reports generated successfully!');
            console.log('📁 Generated files:');
            console.log('  - outputs/pivots.csv');
            console.log('  - outputs/summary.json');
            console.log('  - outputs/report.md');
          } catch (error) {
            console.error('❌ Error generating reports:', error);
            process.exit(1);
          }
          EOF
          
          # Run the data processing
          node process_data.js
          
      - name: Commit and Push Changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          echo "🔍 Checking for changes in outputs/..."
          git status outputs/
          
          # Check if there are changes
          if [ -n "$(git status --porcelain outputs/)" ]; then
            echo "📝 Changes detected, committing..."
            git add outputs/
            git commit -m "auto: update outputs after raw data change"
            git push
            echo "✅ Changes committed and pushed"
          else
            echo "ℹ️  No changes detected in outputs"
          fi